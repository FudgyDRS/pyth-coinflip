{"language":"Solidity","sources":{"src/Coinflip.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport { IEntropyConsumer } from \"@pythnetwork/entropy-sdk-solidity/IEntropyConsumer.sol\";\nimport { IEntropy } from \"@pythnetwork/entropy-sdk-solidity/IEntropy.sol\";\n\ncontract Coinflip is IEntropyConsumer {\n    uint256 public numHeads;\n    uint256 public numTails;\n    uint256 public payoutHeads;\n    uint256 public payoutTails;\n    uint256 public gameNumber;\n    address public owner;\n    IEntropy entropy;\n    uint256 public minGameBuyIn;\n    uint256 public gameIndex;\n    uint256 public vaultBalance;\n    uint256 public gameFeePercent;\n\n\n    enum Status {\n        PENDING, COMPLETE, PAID\n    }\n\n    struct Game {\n        uint256 pot;\n        uint256 anti;\n        address player1;\n        address player2;\n        address winner;\n        Status status;\n    }\n\n    struct Player {\n        uint256 totalBet;\n        uint256 wins;\n        uint256 losses;\n        uint256 amountWon;\n        uint256 amountLost;\n        uint256[] games;\n    }\n\n    mapping(uint256 => Game) gameById;\n    mapping(address => Player) playerByAddress;\n    mapping(uint64 => uint256) gameSequenceNumber;\n\n    event GameCreated(address player, uint256 anti, uint256 gameId);\n    event GamePlayed(address player1, address player2, uint256 pot, uint256 gameId);\n    event GamePaid(uint256 gameId, address winner, uint256 payout);\n\n    error GameError(uint256 gameId, string gameError);\n\n    modifier incrementGameIndex() {\n        _;\n        gameIndex++;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not owner\");\n        _;\n    }\n\n    constructor(address entropy_) {\n        owner = msg.sender;\n        entropy = IEntropy(entropy_);\n        // minGameBuyIn = 5 * 10**18;\n        minGameBuyIn = 0.5 * 10**18; // testing\n    }\n\n    function startGame() public payable incrementGameIndex {\n        require(msg.value >= minGameBuyIn, \"minumum buy-in not reached\");\n\n        gameById[gameIndex] = Game(msg.value, msg.value, msg.sender, address(0), address(0), Status.PENDING);\n        vaultBalance += msg.value;\n        \n        Player storage player = playerByAddress[msg.sender];\n        player.totalBet += msg.value;\n        player.games.push(gameIndex);\n\n        vaultBalance += msg.value;\n        emit GameCreated(msg.sender, msg.value, gameIndex);\n    }\n\n    function joinGame(uint256 gameId) public payable {\n        Game storage game = gameById[gameId];\n        require(msg.value == game.anti);\n        require(game.status == Status.PENDING);\n        require(game.player1 != msg.sender);\n        game.player2 = msg.sender;\n        game.status = Status.COMPLETE;\n\n        Player storage player = playerByAddress[msg.sender];\n        player.totalBet += msg.value;\n        player.games.push(gameIndex);\n\n        address entropyProvider = entropy.getDefaultProvider();\n        uint256 fee = entropy.getFee(entropyProvider);\n        game.pot += msg.value - fee;\n\n        bytes32 userRandomNumber = keccak256(abi.encode(gameId, game.player1, game.player2, block.timestamp));\n        uint64 sequenceNumber = entropy.requestWithCallback{ value: fee }(\n            entropyProvider,\n            userRandomNumber\n        );\n        gameSequenceNumber[sequenceNumber] = gameId;\n\n        vaultBalance += msg.value - fee;\n        emit GamePlayed(game.player1, msg.sender, game.pot, gameId);\n    }\n\n    function entropyCallback(\n        uint64 sequenceNumber,\n        address provider,\n        bytes32 randomNumber\n    ) internal override {\n        bool success;\n        uint256 gameId = gameSequenceNumber[sequenceNumber];\n        Game storage game = gameById[gameId];\n        Player storage player1 = playerByAddress[game.player1];\n        Player storage player2 = playerByAddress[game.player2];\n\n        // fee calculation\n        uint256 fee = game.pot * gameFeePercent / 100;\n        (success,) = owner.call{value: fee}(\"\");\n        require(success, \"fee to owner failed\");\n        uint256 payout = game.pot - fee;\n\n        // result\n        uint256 result = uint256(randomNumber) %2;\n        if(result > 0) {\n            game.winner = game.player1; \n            player1.wins++;\n            player1.amountWon += payout;\n            player2.losses++;\n            player2.amountLost += payout;\n        } else {\n            game.winner = game.player2; \n            player2.wins++;\n            player2.amountWon += payout;\n            player1.losses++;\n            player1.amountLost += payout;\n        }\n\n        (success,) = game.winner.call{value: payout}(\"\");\n        require(success, \"fee to winner failed\");\n\n        vaultBalance -= fee + payout;\n        emit GamePaid(gameId, game.winner, payout);\n    }\n\n    function getEntropy() internal view override returns (address) {\n        return address(entropy);\n    }\n\n    function siphonMisplacedFunds(address token, address to, uint256 amount) public onlyOwner {\n        if(token == address(0)) {\n            uint256 balance = vaultBalance - address(this).balance;\n            (bool success,) = to.call{value: balance}(\"\");\n            require(success, \"eth transfer failed\");\n        } else {\n            bytes memory message = abi.encodeWithSelector(bytes4(keccak256(\"transfer(address,uint256)\")), to, amount);\n            (bool success,) = token.call(message);\n            require(success, \"token transfer failed\");\n        }\n    }\n\n    receive() external payable {}\n}\n"},"node_modules/@pythnetwork/entropy-sdk-solidity/IEntropyConsumer.sol":{"content":"// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.0;\n\nabstract contract IEntropyConsumer {\n    // This method is called by Entropy to provide the random number to the consumer.\n    // It asserts that the msg.sender is the Entropy contract. It is not meant to be\n    // override by the consumer.\n    function _entropyCallback(\n        uint64 sequence,\n        address provider,\n        bytes32 randomNumber\n    ) external {\n        address entropy = getEntropy();\n        require(entropy != address(0), \"Entropy address not set\");\n        require(msg.sender == entropy, \"Only Entropy can call this function\");\n\n        entropyCallback(sequence, provider, randomNumber);\n    }\n\n    // getEntropy returns Entropy contract address. The method is being used to check that the\n    // callback is indeed from Entropy contract. The consumer is expected to implement this method.\n    // Entropy address can be found here - https://docs.pyth.network/entropy/contract-addresses\n    function getEntropy() internal view virtual returns (address);\n\n    // This method is expected to be implemented by the consumer to handle the random number.\n    // It will be called by _entropyCallback after _entropyCallback ensures that the call is\n    // indeed from Entropy contract.\n    function entropyCallback(\n        uint64 sequence,\n        address provider,\n        bytes32 randomNumber\n    ) internal virtual;\n}\n"},"node_modules/@pythnetwork/entropy-sdk-solidity/IEntropy.sol":{"content":"// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.0;\n\nimport \"./EntropyEvents.sol\";\n\ninterface IEntropy is EntropyEvents {\n    // Register msg.sender as a randomness provider. The arguments are the provider's configuration parameters\n    // and initial commitment. Re-registering the same provider rotates the provider's commitment (and updates\n    // the feeInWei).\n    //\n    // chainLength is the number of values in the hash chain *including* the commitment, that is, chainLength >= 1.\n    function register(\n        uint128 feeInWei,\n        bytes32 commitment,\n        bytes calldata commitmentMetadata,\n        uint64 chainLength,\n        bytes calldata uri\n    ) external;\n\n    // Withdraw a portion of the accumulated fees for the provider msg.sender.\n    // Calling this function will transfer `amount` wei to the caller (provided that they have accrued a sufficient\n    // balance of fees in the contract).\n    function withdraw(uint128 amount) external;\n\n    // Withdraw a portion of the accumulated fees for provider. The msg.sender must be the fee manager for this provider.\n    // Calling this function will transfer `amount` wei to the caller (provided that they have accrued a sufficient\n    // balance of fees in the contract).\n    function withdrawAsFeeManager(address provider, uint128 amount) external;\n\n    // As a user, request a random number from `provider`. Prior to calling this method, the user should\n    // generate a random number x and keep it secret. The user should then compute hash(x) and pass that\n    // as the userCommitment argument. (You may call the constructUserCommitment method to compute the hash.)\n    //\n    // This method returns a sequence number. The user should pass this sequence number to\n    // their chosen provider (the exact method for doing so will depend on the provider) to retrieve the provider's\n    // number. The user should then call fulfillRequest to construct the final random number.\n    //\n    // This method will revert unless the caller provides a sufficient fee (at least getFee(provider)) as msg.value.\n    // Note that excess value is *not* refunded to the caller.\n    function request(\n        address provider,\n        bytes32 userCommitment,\n        bool useBlockHash\n    ) external payable returns (uint64 assignedSequenceNumber);\n\n    // Request a random number. The method expects the provider address and a secret random number\n    // in the arguments. It returns a sequence number.\n    //\n    // The address calling this function should be a contract that inherits from the IEntropyConsumer interface.\n    // The `entropyCallback` method on that interface will receive a callback with the generated random number.\n    //\n    // This method will revert unless the caller provides a sufficient fee (at least getFee(provider)) as msg.value.\n    // Note that excess value is *not* refunded to the caller.\n    function requestWithCallback(\n        address provider,\n        bytes32 userRandomNumber\n    ) external payable returns (uint64 assignedSequenceNumber);\n\n    // Fulfill a request for a random number. This method validates the provided userRandomness and provider's proof\n    // against the corresponding commitments in the in-flight request. If both values are validated, this function returns\n    // the corresponding random number.\n    //\n    // Note that this function can only be called once per in-flight request. Calling this function deletes the stored\n    // request information (so that the contract doesn't use a linear amount of storage in the number of requests).\n    // If you need to use the returned random number more than once, you are responsible for storing it.\n    function reveal(\n        address provider,\n        uint64 sequenceNumber,\n        bytes32 userRevelation,\n        bytes32 providerRevelation\n    ) external returns (bytes32 randomNumber);\n\n    // Fulfill a request for a random number. This method validates the provided userRandomness\n    // and provider's revelation against the corresponding commitment in the in-flight request. If both values are validated\n    // and the requestor address is a contract address, this function calls the requester's entropyCallback method with the\n    // sequence number, provider address and the random number as arguments. Else if the requestor is an EOA, it won't call it.\n    //\n    // Note that this function can only be called once per in-flight request. Calling this function deletes the stored\n    // request information (so that the contract doesn't use a linear amount of storage in the number of requests).\n    // If you need to use the returned random number more than once, you are responsible for storing it.\n    //\n    // Anyone can call this method to fulfill a request, but the callback will only be made to the original requester.\n    function revealWithCallback(\n        address provider,\n        uint64 sequenceNumber,\n        bytes32 userRandomNumber,\n        bytes32 providerRevelation\n    ) external;\n\n    function getProviderInfo(\n        address provider\n    ) external view returns (EntropyStructs.ProviderInfo memory info);\n\n    function getDefaultProvider() external view returns (address provider);\n\n    function getRequest(\n        address provider,\n        uint64 sequenceNumber\n    ) external view returns (EntropyStructs.Request memory req);\n\n    function getFee(address provider) external view returns (uint128 feeAmount);\n\n    function getAccruedPythFees()\n        external\n        view\n        returns (uint128 accruedPythFeesInWei);\n\n    function setProviderFee(uint128 newFeeInWei) external;\n\n    function setProviderFeeAsFeeManager(\n        address provider,\n        uint128 newFeeInWei\n    ) external;\n\n    function setProviderUri(bytes calldata newUri) external;\n\n    // Set manager as the fee manager for the provider msg.sender.\n    // After calling this function, manager will be able to set the provider's fees and withdraw them.\n    // Only one address can be the fee manager for a provider at a time -- calling this function again with a new value\n    // will override the previous value. Call this function with the all-zero address to disable the fee manager role.\n    function setFeeManager(address manager) external;\n\n    function constructUserCommitment(\n        bytes32 userRandomness\n    ) external pure returns (bytes32 userCommitment);\n\n    function combineRandomValues(\n        bytes32 userRandomness,\n        bytes32 providerRandomness,\n        bytes32 blockHash\n    ) external pure returns (bytes32 combinedRandomness);\n}\n"},"node_modules/@pythnetwork/entropy-sdk-solidity/EntropyEvents.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./EntropyStructs.sol\";\n\ninterface EntropyEvents {\n    event Registered(EntropyStructs.ProviderInfo provider);\n\n    event Requested(EntropyStructs.Request request);\n    event RequestedWithCallback(\n        address indexed provider,\n        address indexed requestor,\n        uint64 indexed sequenceNumber,\n        bytes32 userRandomNumber,\n        EntropyStructs.Request request\n    );\n\n    event Revealed(\n        EntropyStructs.Request request,\n        bytes32 userRevelation,\n        bytes32 providerRevelation,\n        bytes32 blockHash,\n        bytes32 randomNumber\n    );\n    event RevealedWithCallback(\n        EntropyStructs.Request request,\n        bytes32 userRandomNumber,\n        bytes32 providerRevelation,\n        bytes32 randomNumber\n    );\n\n    event ProviderFeeUpdated(address provider, uint128 oldFee, uint128 newFee);\n\n    event ProviderUriUpdated(address provider, bytes oldUri, bytes newUri);\n\n    event ProviderFeeManagerUpdated(\n        address provider,\n        address oldFeeManager,\n        address newFeeManager\n    );\n\n    event Withdrawal(\n        address provider,\n        address recipient,\n        uint128 withdrawnAmount\n    );\n}\n"},"node_modules/@pythnetwork/entropy-sdk-solidity/EntropyStructs.sol":{"content":"// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\ncontract EntropyStructs {\n    struct ProviderInfo {\n        uint128 feeInWei;\n        uint128 accruedFeesInWei;\n        // The commitment that the provider posted to the blockchain, and the sequence number\n        // where they committed to this. This value is not advanced after the provider commits,\n        // and instead is stored to help providers track where they are in the hash chain.\n        bytes32 originalCommitment;\n        uint64 originalCommitmentSequenceNumber;\n        // Metadata for the current commitment. Providers may optionally use this field to help\n        // manage rotations (i.e., to pick the sequence number from the correct hash chain).\n        bytes commitmentMetadata;\n        // Optional URI where clients can retrieve revelations for the provider.\n        // Client SDKs can use this field to automatically determine how to retrieve random values for each provider.\n        // TODO: specify the API that must be implemented at this URI\n        bytes uri;\n        // The first sequence number that is *not* included in the current commitment (i.e., an exclusive end index).\n        // The contract maintains the invariant that sequenceNumber <= endSequenceNumber.\n        // If sequenceNumber == endSequenceNumber, the provider must rotate their commitment to add additional random values.\n        uint64 endSequenceNumber;\n        // The sequence number that will be assigned to the next inbound user request.\n        uint64 sequenceNumber;\n        // The current commitment represents an index/value in the provider's hash chain.\n        // These values are used to verify requests for future sequence numbers. Note that\n        // currentCommitmentSequenceNumber < sequenceNumber.\n        //\n        // The currentCommitment advances forward through the provider's hash chain as values\n        // are revealed on-chain.\n        bytes32 currentCommitment;\n        uint64 currentCommitmentSequenceNumber;\n        // An address that is authorized to set / withdraw fees on behalf of this provider.\n        address feeManager;\n    }\n\n    struct Request {\n        // Storage slot 1 //\n        address provider;\n        uint64 sequenceNumber;\n        // The number of hashes required to verify the provider revelation.\n        uint32 numHashes;\n        // Storage slot 2 //\n        // The commitment is keccak256(userCommitment, providerCommitment). Storing the hash instead of both saves 20k gas by\n        // eliminating 1 store.\n        bytes32 commitment;\n        // Storage slot 3 //\n        // The number of the block where this request was created.\n        // Note that we're using a uint64 such that we have an additional space for an address and other fields in\n        // this storage slot. Although block.number returns a uint256, 64 bits should be plenty to index all of the\n        // blocks ever generated.\n        uint64 blockNumber;\n        // The address that requested this random number.\n        address requester;\n        // If true, incorporate the blockhash of blockNumber into the generated random value.\n        bool useBlockhash;\n        // If true, the requester will be called back with the generated random value.\n        bool isRequestWithCallback;\n        // There are 2 remaining bytes of free space in this slot.\n    }\n}\n"}},"settings":{"remappings":["@pythnetwork/entropy-sdk-solidity/=node_modules/@pythnetwork/entropy-sdk-solidity/","@/=src/","src/=src/","forge-std/=lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}
